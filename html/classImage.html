<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.9.8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Image Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectalign">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.8 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classImage-members.html">List of all members</a>  </div>
  <div class="headertitle"><div class="title">Image Class Reference</div></div>
</div><!--header-->
<div class="contents">

<p>A class representing a digital image.  
 <a href="classImage.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="Image_8h_source.html">Image.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a id="pub-methods" name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a199300f493ceee764bad108dc57ebe81" id="r_a199300f493ceee764bad108dc57ebe81"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a199300f493ceee764bad108dc57ebe81">Image</a> (const char *FileName)</td></tr>
<tr class="memdesc:a199300f493ceee764bad108dc57ebe81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Construct a new <a class="el" href="classImage.html" title="A class representing a digital image.">Image</a> object from a file.  <br /></td></tr>
<tr class="separator:a199300f493ceee764bad108dc57ebe81"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0294f63700543e11c0f0da85601c7ae5" id="r_a0294f63700543e11c0f0da85601c7ae5"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a0294f63700543e11c0f0da85601c7ae5">~Image</a> ()</td></tr>
<tr class="memdesc:a0294f63700543e11c0f0da85601c7ae5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroy the <a class="el" href="classImage.html" title="A class representing a digital image.">Image</a> object and free the memory used by the pixel data.  <br /></td></tr>
<tr class="separator:a0294f63700543e11c0f0da85601c7ae5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7a2e0b96c733ce9950bb3616f2f0f2b5" id="r_a7a2e0b96c733ce9950bb3616f2f0f2b5"><td class="memItemLeft" align="right" valign="top">int *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a7a2e0b96c733ce9950bb3616f2f0f2b5">Metadata</a> ()</td></tr>
<tr class="memdesc:a7a2e0b96c733ce9950bb3616f2f0f2b5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get the metadata of the image.  <br /></td></tr>
<tr class="separator:a7a2e0b96c733ce9950bb3616f2f0f2b5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72701be7249590c9296ca56c77bb4c53" id="r_a72701be7249590c9296ca56c77bb4c53"><td class="memItemLeft" align="right" valign="top"><a class="el" href="structPixel.html">Pixel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a72701be7249590c9296ca56c77bb4c53">PixelData</a> ()</td></tr>
<tr class="memdesc:a72701be7249590c9296ca56c77bb4c53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get a pointer to the pixel data of the image.  <br /></td></tr>
<tr class="separator:a72701be7249590c9296ca56c77bb4c53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac3aed30306e37288a62a5208e20df9a3" id="r_ac3aed30306e37288a62a5208e20df9a3"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ac3aed30306e37288a62a5208e20df9a3">WriteImage</a> (const char *FileName)</td></tr>
<tr class="memdesc:ac3aed30306e37288a62a5208e20df9a3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write the image to a file.  <br /></td></tr>
<tr class="separator:ac3aed30306e37288a62a5208e20df9a3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac07481209ed8eb57fed9113895243e62" id="r_ac07481209ed8eb57fed9113895243e62"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ac07481209ed8eb57fed9113895243e62">WriteImageWaterMark</a> (<a class="el" href="classImage.html">Image</a> &amp;watermarkImage)</td></tr>
<tr class="memdesc:ac07481209ed8eb57fed9113895243e62"><td class="mdescLeft">&#160;</td><td class="mdescRight">Write a watermark image to the image.  <br /></td></tr>
<tr class="separator:ac07481209ed8eb57fed9113895243e62"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a23083e77ac0ed2250f3a071e0390b265" id="r_a23083e77ac0ed2250f3a071e0390b265"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a23083e77ac0ed2250f3a071e0390b265">DisplayImage</a> ()</td></tr>
<tr class="memdesc:a23083e77ac0ed2250f3a071e0390b265"><td class="mdescLeft">&#160;</td><td class="mdescRight">Display the image on the screen.  <br /></td></tr>
<tr class="separator:a23083e77ac0ed2250f3a071e0390b265"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a94bd23e1d767245aefcae0fde6ef2de4" id="r_a94bd23e1d767245aefcae0fde6ef2de4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a94bd23e1d767245aefcae0fde6ef2de4">RGBtoYUV</a> ()</td></tr>
<tr class="memdesc:a94bd23e1d767245aefcae0fde6ef2de4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the image from RGB to YUV color space.  <br /></td></tr>
<tr class="separator:a94bd23e1d767245aefcae0fde6ef2de4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac403389311a1302dea67b365c861f686" id="r_ac403389311a1302dea67b365c861f686"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ac403389311a1302dea67b365c861f686">YUVtoRGB</a> ()</td></tr>
<tr class="memdesc:ac403389311a1302dea67b365c861f686"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the image from YUV to RGB color space.  <br /></td></tr>
<tr class="separator:ac403389311a1302dea67b365c861f686"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af5a0d91927ef6d932700b6054792f759" id="r_af5a0d91927ef6d932700b6054792f759"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#af5a0d91927ef6d932700b6054792f759">CalculateAndDisplayHistograms</a> ()</td></tr>
<tr class="memdesc:af5a0d91927ef6d932700b6054792f759"><td class="mdescLeft">&#160;</td><td class="mdescRight">Calculate and display the histograms of the image.  <br /></td></tr>
<tr class="separator:af5a0d91927ef6d932700b6054792f759"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8c596c19c7fc336cbf08766229f58abf" id="r_a8c596c19c7fc336cbf08766229f58abf"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a8c596c19c7fc336cbf08766229f58abf">ApplyHistogramEqualization</a> ()</td></tr>
<tr class="memdesc:a8c596c19c7fc336cbf08766229f58abf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply histogram equalization to the V channel of the image in the HSV color space.  <br /></td></tr>
<tr class="separator:a8c596c19c7fc336cbf08766229f58abf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0bb0405618ac66a6dc7966d1c9c7cc47" id="r_a0bb0405618ac66a6dc7966d1c9c7cc47"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a0bb0405618ac66a6dc7966d1c9c7cc47">ConvertToGrayscale</a> ()</td></tr>
<tr class="memdesc:a0bb0405618ac66a6dc7966d1c9c7cc47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convert the image to grayscale.  <br /></td></tr>
<tr class="separator:a0bb0405618ac66a6dc7966d1c9c7cc47"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0c70fe199b6e324569030a93edaeea9" id="r_ae0c70fe199b6e324569030a93edaeea9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#ae0c70fe199b6e324569030a93edaeea9">GaussianFilter</a> (int kernelSize, double sigma)</td></tr>
<tr class="memdesc:ae0c70fe199b6e324569030a93edaeea9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a Gaussian filter to the image.  <br /></td></tr>
<tr class="separator:ae0c70fe199b6e324569030a93edaeea9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a88a6c522d11c4e782d36e5861d1c35f5" id="r_a88a6c522d11c4e782d36e5861d1c35f5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a88a6c522d11c4e782d36e5861d1c35f5">BlurFilter</a> (int kernelSize)</td></tr>
<tr class="memdesc:a88a6c522d11c4e782d36e5861d1c35f5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply a blur filter to the image.  <br /></td></tr>
<tr class="separator:a88a6c522d11c4e782d36e5861d1c35f5"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5987f1a33b2d5e0c9e1822ef8cb3e0ec" id="r_a5987f1a33b2d5e0c9e1822ef8cb3e0ec"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classImage.html#a5987f1a33b2d5e0c9e1822ef8cb3e0ec">ThresholdSegmentation</a> (int threshold)</td></tr>
<tr class="memdesc:a5987f1a33b2d5e0c9e1822ef8cb3e0ec"><td class="mdescLeft">&#160;</td><td class="mdescRight">Apply threshold segmentation to the image.  <br /></td></tr>
<tr class="separator:a5987f1a33b2d5e0c9e1822ef8cb3e0ec"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>A class representing a digital image. </p>
<p>The <code><a class="el" href="classImage.html" title="A class representing a digital image.">Image</a></code> class represents a digital image, with methods for reading and writing image files, applying various image processing operations, and displaying the image on the screen. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a199300f493ceee764bad108dc57ebe81" name="a199300f493ceee764bad108dc57ebe81"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a199300f493ceee764bad108dc57ebe81">&#9670;&#160;</a></span>Image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Image::Image </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Construct a new <a class="el" href="classImage.html" title="A class representing a digital image.">Image</a> object from a file. </p>
<p>Construct a new <a class="el" href="classImage.html#a199300f493ceee764bad108dc57ebe81" title="Construct a new Image object from a file.">Image::Image</a> object from a ppm (P6) file.</p>
<p>The constructor reads an image file from disk and creates a new <code><a class="el" href="classImage.html" title="A class representing a digital image.">Image</a></code> object from it.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>The name of the image file to read</td></tr>
  </table>
  </dd>
</dl>
<p>The constructor reads the ppm file and stores the pixel data in the object</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FilePath</td><td>Path to the image file </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file cannot be opened </td></tr>
    <tr><td class="paramname">std::runtime_error</td><td>if the file is not a ppm file </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a0294f63700543e11c0f0da85601c7ae5" name="a0294f63700543e11c0f0da85601c7ae5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0294f63700543e11c0f0da85601c7ae5">&#9670;&#160;</a></span>~Image()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">Image::~Image </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroy the <a class="el" href="classImage.html" title="A class representing a digital image.">Image</a> object and free the memory used by the pixel data. </p>
<p>The destructor frees the memory used by the pixel data of the image. </p>

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a8c596c19c7fc336cbf08766229f58abf" name="a8c596c19c7fc336cbf08766229f58abf"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8c596c19c7fc336cbf08766229f58abf">&#9670;&#160;</a></span>ApplyHistogramEqualization()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::ApplyHistogramEqualization </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply histogram equalization to the V channel of the image in the HSV color space. </p>
<p>The <code>ApplyHistogramEqualization</code> method applies histogram equalization to the V channel of the image in the HSV color space.</p>
<p>The function first creates a <code>Mat</code> object from the <code>pixels</code> array and converts it to the HSV color space using the <code>cvtColor</code> function. It then splits the HSV channels into separate <code>Mat</code> objects and calculates the histogram of the V channel using the <code>calcHist</code> function. The function applies histogram equalization to the V channel using the <code>equalizeHist</code> function. It then merges the channels back into the HSV image using the <code>merge</code> function and converts it back to the BGR color space using the <code>cvtColor</code> function. Finally, the function copies the modified pixels back to the <code>pixels</code> array using the <code>memcpy</code> function and displays the histogram using the <code>imshow</code> function. </p>

</div>
</div>
<a id="a88a6c522d11c4e782d36e5861d1c35f5" name="a88a6c522d11c4e782d36e5861d1c35f5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a88a6c522d11c4e782d36e5861d1c35f5">&#9670;&#160;</a></span>BlurFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::BlurFilter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernelSize</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a blur filter to the image. </p>
<p>The <code>BlurFilter</code> method applies a blur filter to the image using the specified kernel size.</p>
<p>The function applies a blur filter to the image using the specified kernel size. The blur kernel is created using the specified kernel size and is normalized to sum to 1. The function then applies the blur filter to the image by convolving the kernel with each pixel in the image. The function uses a temporary buffer to store the original pixel values during the convolution process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernelSize</td><td>The size of the blur kernel (must be odd)</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if kernelSize is even or less than 3 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="af5a0d91927ef6d932700b6054792f759" name="af5a0d91927ef6d932700b6054792f759"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af5a0d91927ef6d932700b6054792f759">&#9670;&#160;</a></span>CalculateAndDisplayHistograms()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::CalculateAndDisplayHistograms </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Calculate and display the histograms of the image. </p>
<p>Calculate and display histograms for the R, G, and B channels of the image.</p>
<p>The <code>CalculateAndDisplayHistograms</code> method calculates and displays the histograms of the image using OpenCV.</p>
<p>The function calculates histograms for the R, G, and B channels of the image and displays them in a window. The histograms are normalized to fit within the display area, and a grid and axes are drawn to aid in interpretation. The function uses OpenCV's <code>Mat</code> class to create and display the histogram plot. </p>

</div>
</div>
<a id="a0bb0405618ac66a6dc7966d1c9c7cc47" name="a0bb0405618ac66a6dc7966d1c9c7cc47"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0bb0405618ac66a6dc7966d1c9c7cc47">&#9670;&#160;</a></span>ConvertToGrayscale()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::ConvertToGrayscale </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the image to grayscale. </p>
<p>The <code>ConvertToGrayscale</code> method converts the image to grayscale by taking the average of its red, green, and blue values. </p>

</div>
</div>
<a id="a23083e77ac0ed2250f3a071e0390b265" name="a23083e77ac0ed2250f3a071e0390b265"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a23083e77ac0ed2250f3a071e0390b265">&#9670;&#160;</a></span>DisplayImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::DisplayImage </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Display the image on the screen. </p>
<p>The <code>DisplayImage</code> method displays the image on the screen using OpenCV. </p>

</div>
</div>
<a id="ae0c70fe199b6e324569030a93edaeea9" name="ae0c70fe199b6e324569030a93edaeea9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0c70fe199b6e324569030a93edaeea9">&#9670;&#160;</a></span>GaussianFilter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::GaussianFilter </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>kernelSize</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">double&#160;</td>
          <td class="paramname"><em>sigma</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply a Gaussian filter to the image. </p>
<p>The <code>GaussianFilter</code> method applies a Gaussian filter to the image using the specified kernel size and sigma value.</p>
<p>The function applies a Gaussian filter to the image using the specified kernel size and sigma value. The Gaussian kernel is created using the specified kernel size and sigma value, and is normalized to sum to 1. The function then applies the Gaussian filter to the image by convolving the kernel with each pixel in the image. The function uses a temporary buffer to store the original pixel values during the convolution process.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">kernelSize</td><td>The size of the Gaussian kernel (must be odd) </td></tr>
    <tr><td class="paramname">sigma</td><td>The standard deviation of the Gaussian distribution</td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::invalid_argument</td><td>if kernelSize is even or less than 3, or if sigma is less than or equal to 0 </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a7a2e0b96c733ce9950bb3616f2f0f2b5" name="a7a2e0b96c733ce9950bb3616f2f0f2b5"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7a2e0b96c733ce9950bb3616f2f0f2b5">&#9670;&#160;</a></span>Metadata()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int * Image::Metadata </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get the metadata of the image. </p>
<p>The <code>Metadata</code> method returns an array of integers containing the width, height, and maximum pixel value of the image.</p>
<dl class="section return"><dt>Returns</dt><dd>An array of integers containing the width, height, and maximum pixel value of the image</dd></dl>
<p>The function returns an array of integers containing the width, height, and maximum pixel value of the image.</p>
<dl class="section return"><dt>Returns</dt><dd>An array of integers containing the width, height, and maximum pixel value of the image </dd></dl>

</div>
</div>
<a id="a72701be7249590c9296ca56c77bb4c53" name="a72701be7249590c9296ca56c77bb4c53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72701be7249590c9296ca56c77bb4c53">&#9670;&#160;</a></span>PixelData()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="structPixel.html">Pixel</a> * Image::PixelData </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get a pointer to the pixel data of the image. </p>
<p>Get the pixel data of the image.</p>
<p>The <code>PixelData</code> method returns a pointer to the pixel data of the image.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to the pixel data of the image</dd></dl>
<p>The function returns a pointer to an array of <code><a class="el" href="structPixel.html" title="A struct representing a pixel in an image.">Pixel</a></code> objects containing the pixel data of the image.</p>
<dl class="section return"><dt>Returns</dt><dd>A pointer to an array of <code><a class="el" href="structPixel.html" title="A struct representing a pixel in an image.">Pixel</a></code> objects containing the pixel data of the image </dd></dl>

</div>
</div>
<a id="a94bd23e1d767245aefcae0fde6ef2de4" name="a94bd23e1d767245aefcae0fde6ef2de4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a94bd23e1d767245aefcae0fde6ef2de4">&#9670;&#160;</a></span>RGBtoYUV()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::RGBtoYUV </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the image from RGB to YUV color space. </p>
<p>Convert the image from RGB color space to YUV color space.</p>
<p>The <code>RGBtoYUV</code> method converts the image from RGB color space to YUV color space.</p>
<p>The function converts the pixel data of the image from RGB color space to YUV color space. The conversion formula used is based on the ITU-R BT.601 standard. </p>

</div>
</div>
<a id="a5987f1a33b2d5e0c9e1822ef8cb3e0ec" name="a5987f1a33b2d5e0c9e1822ef8cb3e0ec"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a5987f1a33b2d5e0c9e1822ef8cb3e0ec">&#9670;&#160;</a></span>ThresholdSegmentation()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::ThresholdSegmentation </td>
          <td>(</td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>threshold</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Apply threshold segmentation to the image. </p>
<p>The <code>ThresholdSegmentation</code> method applies threshold segmentation to the image using the specified threshold value.</p>
<p>The function applies threshold segmentation to the image using the specified threshold value. The function converts each pixel to grayscale by taking the average of its red, green, and blue values. If the grayscale value of a pixel is less than the threshold value, the pixel is set to black (0, 0, 0). Otherwise, the pixel is set to white (255, 255, 255).</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">threshold</td><td>The threshold value for segmentation </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac3aed30306e37288a62a5208e20df9a3" name="ac3aed30306e37288a62a5208e20df9a3"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac3aed30306e37288a62a5208e20df9a3">&#9670;&#160;</a></span>WriteImage()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::WriteImage </td>
          <td>(</td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>FileName</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write the image to a file. </p>
<p>Write the image to a ppm (P6) file.</p>
<p>The <code>WriteImage</code> method writes the image to a file with the specified name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>The name of the file to write the image to</td></tr>
  </table>
  </dd>
</dl>
<p>The function writes the pixel data of the image to a ppm file with the specified file name.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">FileName</td><td>Path to the output file </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the file cannot be opened </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac07481209ed8eb57fed9113895243e62" name="ac07481209ed8eb57fed9113895243e62"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac07481209ed8eb57fed9113895243e62">&#9670;&#160;</a></span>WriteImageWaterMark()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::WriteImageWaterMark </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classImage.html">Image</a> &amp;&#160;</td>
          <td class="paramname"><em>watermarkImage</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Write a watermark image to the image. </p>
<p>Write the image with a watermark to a window.</p>
<p>The <code>WriteImageWaterMark</code> method writes a watermark image to the image.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">watermarkImage</td><td>The watermark image to write to the image</td></tr>
  </table>
  </dd>
</dl>
<p>The function overlays the specified watermark image onto the original image and displays the result in a window.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">watermarkImage</td><td>The watermark image to be overlaid onto the original image </td></tr>
  </table>
  </dd>
</dl>
<dl class="exception"><dt>Exceptions</dt><dd>
  <table class="exception">
    <tr><td class="paramname">std::runtime_error</td><td>if the watermark image dimensions are larger than the original image </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ac403389311a1302dea67b365c861f686" name="ac403389311a1302dea67b365c861f686"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac403389311a1302dea67b365c861f686">&#9670;&#160;</a></span>YUVtoRGB()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Image::YUVtoRGB </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convert the image from YUV to RGB color space. </p>
<p>Convert the image from YUV color space to RGB color space.</p>
<p>The <code>YUVtoRGB</code> method converts the image from YUV color space to RGB color space.</p>
<p>The function converts the pixel data of the image from YUV color space to RGB color space. The conversion formula used is based on the ITU-R BT.601 standard. </p>

</div>
</div>
<hr/>The documentation for this class was generated from the following files:<ul>
<li>include/<a class="el" href="Image_8h_source.html">Image.h</a></li>
<li>src/<a class="el" href="Image_8cpp.html">Image.cpp</a></li>
</ul>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.8
</small></address>
</body>
</html>
